Paso 1: Crear el contexto del carrito

Este archivo introduce React Context API, una herramienta esencial para gestionar estado global en aplicaciones React. En lugar de pasar el carrito y sus funciones manualmente entre componentes (lo que genera prop drilling), el contexto permite que cualquier componente acceda directamente al estado del carrito de forma limpia y eficiente. Aunque la lÃ³gica del carrito (agregar, eliminar, persistencia, etc.) ya fue implementada en la Etapa 3.1, ahora se reorganiza dentro de un sistema centralizado que mejora la escalabilidad y mantenibilidad del cÃ³digo.

Crea una nueva carpeta: src/context/
Dentro, crea el archivo: CarritoContext.jsx

Este archivo introduce React Context API, una herramienta poderosa de React para compartir estado y funciones entre muchos componentes sin tener que pasar props manualmente (lo que se conoce como prop drilling).

Aunque las funciones del carrito (agregar, eliminar, etc.) ya las conocemos, la forma en que se organizan y se ponen a disposiciÃ³n de toda la app es completamente nueva.

 1. createContext(): Creamos un "canal" de comunicaciÃ³n
    
    const CarritoContext = createContext();

    Esto crea un contexto vacÃ­o llamado CarritoContext.

    Piensa en el contexto como un canal de televisiÃ³n: cualquier componente que "sintonice" este canal podrÃ¡ recibir los datos que se emiten.


 2. useCarrito(): Un hook personalizado para acceder al contexto

    export const useCarrito = () => {
    const context = useContext(CarritoContext);
    if (!context) {
        throw new Error('useCarrito debe usarse dentro de un CarritoProvider');
    }
    return context;
    };

    Este es un hook personalizado que envuelve useContext(CarritoContext).

    Ventajas:
    Evita tener que importar useContext y CarritoContext en cada componente.
    Agrega una validaciÃ³n de seguridad: si alguien usa useCarrito() fuera del proveedor, lanza un error claro.
    Es como crear un "acceso directo" al carrito.

 3. CarritoProvider: El "emisor" del canal

    export const CarritoProvider = ({ children }) => {
        // ... estado y funciones del carrito

        return (
            <CarritoContext.Provider value={{ carrito, agregarAlCarrito, ... }}>
            {children}
            </CarritoContext.Provider>
        );
    };

    Este componente envuelve toda la aplicaciÃ³n (en App.jsx).
    El value es lo que se "emite" por el canal: todo el estado y todas las funciones del carrito.
    Cualquier componente dentro de {children} podrÃ¡ acceder a ese value usando useCarrito().

ğŸ’¡ AnalogÃ­a: 
    CarritoProvider = la antena que transmite la seÃ±al.
    useCarrito() = el televisor que recibe la seÃ±al.
    Sin antena, no hay seÃ±al. Sin televisor, no ves nada.


 4. Persistencia con localStorage dentro del proveedor

    const [carrito, setCarrito] = useState(getInitialCart);

    useEffect(() => {
    localStorage.setItem('carrito', JSON.stringify(carrito));
    }, [carrito]);

    La lÃ³gica de localStorage se mantiene igual que en la Etapa 3.1, pero ahora vive dentro del contexto.
    Esto significa que el estado persistente estÃ¡ centralizado y no depende de App.jsx.

 5. Â¿Por quÃ© exportamos dos cosas?

    export const useCarrito = () => { ... }
    export const CarritoProvider = ({ children }) => { ... }

    CarritoProvider: se usa una sola vez en App.jsx para envolver la app.
    useCarrito: se usa en cualquier componente que necesite el carrito (Header, Cardprod, Offcanvas, etc.).




âœ… Resumen: Â¿QuÃ© ganamos con esto?

Etapa 3.1 (con props)                                   Etapa 3.2(con context)
---------------------------------------------------------------------------------------------
El carrito vivÃ­a en App.jsx                         El carrito vive en CarritoContext

HabÃ­a que pasar carrito y funciones                 Cualquier componente accede directamente con useCarrito()
como props a travÃ©s de 3-4 componentes 

CÃ³digo repetitivo y difÃ­cil de escalar              CÃ³digo limpio, modular y escalable

App.jsx se volvÃ­a muy grande                        App.jsx se mantiene limpio; 
                                                    la lÃ³gica del carrito estÃ¡ aislada


â€œContext API no reemplaza useState ni useEffect.
Simplemente organiza mejor el estado global para que sea accesible en toda la app, sin ensuciar el flujo de props.â€ 



Paso 2: Envolver la app con CarritoProvider

    // src/App.jsx
    import { BrowserRouter } from 'react-router-dom';
    import { CarritoProvider } from './context/CarritoContext'; // ğŸ‘ˆ

    import Header from './components/Header';
    import Footer from './components/Footer';
    // ... otros imports

    const App = () => {
    // ... tu lÃ³gica de darkMode (sin carrito aquÃ­)

    return (
        <CarritoProvider> {/* ğŸ‘ˆ Envuelve TODO */}
        <BrowserRouter>
            <div className="app">
            <Header darkMode={darkMode} toggleTheme={toggleTheme} />
            {/* Routes */}
            <Footer />
            </div>
        </BrowserRouter>
        </CarritoProvider>
    );
    };

    export default App;

 Paso 3: Usar el contexto en los componentes

    // src/components/Header.jsx
    import { useCarrito } from '../context/CarritoContext'; // ğŸ‘ˆ

    const Header = ({ darkMode, toggleTheme }) => {
        const { carrito } = useCarrito(); // ğŸ‘ˆ

        return (
            <nav>...</nav>
            
            {carrito.length > 0 && (
            <button className="btn btn-outline-primary ms-2">
                ğŸ›’ Carrito ({carrito.length})
            </button>
            )}

            {/* Offcanvas aquÃ­ tambiÃ©n usarÃ¡ useCarrito() */}
        );
    };